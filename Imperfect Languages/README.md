# Fibonacci Project : Imperfect Languages
So there is a section in the main README.md file in the normal repository that specifies rules. These languages are either test languages or just simply languages that have no way to bend the rules into their favor.

### What does this mean?
Basically languages that cannot hit the full marks demonstrated by the prime examples in the directory above. This can be code written by other people who couldn't get it to work and me [Kai Lyons](https://github.com/KaiLyons) could not fix it.

### Can a language be promoted to the main directory?
Yes, if we find a way to make it work that not only conforms to the standards but also meet new expectations.

### X language is in the directory above and it doesn't work with Y rule, why does Z language get sent here?
For example lanugages like Haskell, Elixir, and Lolcode all do not have while OR for loops, but they have work arounds. If Z language is here it doesn't meet a written or unwritten requirement.

### What unwritten requirements are there?
So to make it here, it could be that
- Different compilers might not work while others do
- They don't meet the requirement of how many things are here
  - This number is equal to 3524578 or higher (as some compilers hit this number or go up to 9227465 but as long as 3524578 is present it is safe to be in the main directory)
- Uncompiled example (Possibly from: [examples below])
  - Non-existant compilers
  - Compilers with issues/bugs
  - A library that cannot be found
  - Non-Linux compatible compilers
  - Compilers that might work but take too long to install (I have had compilers take hours to install)
  - Non-compliant compilers
    - Languages that run on standards, but multiple implementation compilers exist (such as GNU Compiler Collection) but that do not comply with the modern examples/standards
    - Doesn't apply if an example of some form is able to run in a "non-compliant" compiler
